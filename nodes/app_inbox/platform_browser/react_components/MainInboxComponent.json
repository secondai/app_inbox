{
  "type": "react_component:0.0.1:local:98912hd89",
  "name": "MainInboxComponent",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "1",
    "key": "ed795e5b-0606-4eb9-8168-c859a77cdfe4",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      let ErrorComponent = (name) => {\n        return class ErrorComponent extends React.Component {\n          constructor(props){\n            super(props);\n            this.state = {}\n          }\n          \n          render(){\n            return (\n              <div>\n                ErrorLoading: {name || 'unknown'}\n              </div>\n            )\n          }\n        }\n      }\n    \n      class OutputErrorCatcherComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {}\n        }\n        \n        componentDidCatch(error, info) {\n          // Display fallback UI\n          this.setState({ hasError: true });\n          // You can also log the error to an error reporting service\n          console.error('MainHomeComponent OutputErrorCatcherComponent componentDidCatch:', error, info);\n        }\n        \n        render(){\n          if(this.state.hasError){\n            return (\n            <div>\n              OutputErrorCatcher\n              <br />\n              <pre><code>[TODO, error output]</code></pre>\n            </div>\n            )\n          }\n          \n          // normal\n          return this.props.children;\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          let searchIdentity;\n          try {\n            searchIdentity = props.state.OwnerSecondExternalIdentityNode.data.identity;\n          }catch(err){\n            console.error('Missing props.state.OwnerSecondExternalIdentityNode.data.identity', err);\n          }\n          \n          this.state = {\n            inboxNodes: [],\n            selectedMessageNode: null, // when selected\n            runningPackages: [],\n            groups: [], \n            allExternalConnections: [], \n            searchIdentity,\n            filterText: '',\n            postText: '',\n            postDescription: '',\n            postGroupNodeId: '', \n            isPosting: false,\n            tabsPackageMainSelected: 'details',\n            sharedNodeTypes: [\n              'code_package',\n              'situation_package'\n            ],\n            selectedSharedNodeType: 'code_package'\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Loaded MainHomeComponent');\n            \n          this.startup();\n            \n        }\n        \n        componentWillReceiveProps(nextProps){\n          if(!this.props.state.OwnerSecondExternalIdentityNode && !this.props.state.OwnerSecondExternalIdentityNode && \n            nextProps.state.OwnerSecondExternalIdentityNode && nextProps.state.OwnerSecondExternalIdentityNode){\n              console.log('Running startup now');\n              this.startup();\n          }\n        }\n        \n        @autobind\n        async startup(){\n          // this.fetchGroups();\n          // this.fetchExternalConnections();\n          \n          if(this.props.state.OwnerSecondExternalIdentityNode && \n             this.props.state.OwnerSecondExternalIdentityNode.data.token){\n            // this.fetchFromRemoteForIdentity(this.props);\n            await this.fetchGroups();\n            await this.fetchExternalConnections();\n            await this.fetchSelected(); // expecting mine to be selected?\n          }\n          \n        }\n        \n        @autobind\n        fetchGroups(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingGroups: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              dataFilter: {\n                                nodeId: null,\n                                type: {\n                                  $like: 'group_for_sharing:'\n                                }\n                              },\n                              matchFunctionNode: null\n                              // {\n                              //   // query here!\n                              //   // action_pointer:0.0.1:local:238972ncr\n                              //   type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                              //   data: {\n                              //     code: `(()=>{\n                              //       // Action \n                              //       // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                              //       let inputNode = INPUT.data.inputNode;\n                                    \n                              //       if(inputNode.nodeId){\n                              //         return false;\n                              //       }\n                                    \n                              //       if(inputNode.type.split(':')[0] != 'group_for_sharing'){\n                              //         return false;\n                              //       }\n                                    \n                              //       return inputNode;\n                                    \n                              //     })()`\n                              //   }\n                              // },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[1].data;\n            \n            console.log('Group Nodes:', nodes);\n            \n            let postGroupNodeId = this.state.postGroupNodeId;\n            if(!postGroupNodeId){\n              postGroupNodeId = nodes.find(node=>{\n                return node.data.name == 'Private';\n              });\n              if(postGroupNodeId){\n                postGroupNodeId = postGroupNodeId._id;\n              }\n            }\n            \n            this.setState({\n              groups: nodes,\n              postGroupNodeId,\n              fetchingGroups: false\n            }, resolve);\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchExternalConnections(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            this.setState({\n              fetchingConnections: true\n            });\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                          }\n                        },\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              dataFilter: {\n                                nodeId: null,\n                                type: {\n                                  $like: 'external_identity:'\n                                }\n                              },\n                              matchFunctionNode: null,\n                              // {\n                              //   // query here!\n                              //   // action_pointer:0.0.1:local:238972ncr\n                              //   type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                              //   data: {\n                              //     code: `(()=>{\n                              //       // Action \n                              //       // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                              //       let inputNode = INPUT.data.inputNode;\n                                    \n                              //       if(inputNode.nodeId){\n                              //         return false;\n                              //       }\n                                    \n                              //       if(inputNode.type.split(':')[0] != 'external_identity'){\n                              //         return false;\n                              //       }\n                                    \n                              //       return inputNode;\n                                    \n                              //     })()`\n                              //   }\n                              // },\n                              // expected/allowed schemas for return \n                              // outputSchemas: [\n                              //   'query_result:0.0.1:local:32490usfj23o23f',\n                              //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                              // ]\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            console.log('fetchExternalConnections Response:', response);\n            \n            let nodes = response.data.actionResponses[1].data;\n            \n            this.setState({\n              allExternalConnections: nodes,\n              fetchingConnections: false\n            }, this.updateConnectionGroups);\n            \n            resolve(nodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        fetchSelected(){\n          // fetch Mine or Remote depending on selected from select \n          \n          if(this.props.state.OwnerSecondExternalIdentityNode.data.identity == this.state.searchIdentity){\n            this.fetchMine();\n          } else {\n            this.fetchFromRemoteForIdentity(); \n          }\n          \n        }\n        \n        @autobind\n        fetchMine(){\n          // shared_node\n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingMine: true\n              })\n              \n              // Get my identity \n              // - should use \"signer\" instead? \n              // - or just look for ones where signer=author \n              let author = this.props.state.OwnerSecondExternalIdentityNode.data.identity; // \"idtest:nick\" or \"internal:main\" ? \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                      \n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                dataFilter: {\n                                  nodeId: null,\n                                  type: {\n                                    $like: 'wrapped_message_node:'\n                                  }\n                                },\n                                matchFunctionNode: null\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data;\n              \n              console.log('nodes:', nodes);\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              // let inboxNodes = universe.lodash.uniqBy(nodes, node=>{\n              //   // uniq filter \n              //   return node.data._id; // unique id of source (identity:address) \n              // })\n              let inboxNodes = nodes.sort((a,b)=>{\n                // newest at top \n                try {\n                  return a.createdAt < b.createdAt;\n                }catch(err){\n                  console.error('sharedErr:', a, b, err);\n                }\n                return 0;\n              });\n              // function getChildren(nodes){\n              //   nodes.map(node=>{\n                  \n              //   })\n              // }\n              // getChildren(nodes);\n              \n              // console.log('SharedDataNodes', SharedDataNodes);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                inboxNodes,\n                fetchingMine: false\n              })\n              \n            } catch(err){\n              console.error('Failed getting local nodes', err);\n              \n              this.setState({\n                fetchingMine: false\n              })\n              \n            }\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        fetchFromRemoteForIdentity(props){\n          // fetching data from a remote (syndicated-to) Second \n          // - data for a Single person's thread \n          \n          this.setState({\n            fetchingRemote: true\n          });\n          \n          props = props || this.props;\n          \n          console.log('fetchFromRemoteForIdentity.New Props', props);\n          console.log('this.props.state.OwnerSecondExternalIdentityNode', this.props.state.OwnerSecondExternalIdentityNode);\n          \n          let {\n            viewingIdentity,\n            searchIdentity\n          } = this.state;\n          \n          let viewIdentity = viewingIdentity;\n          \n          console.log('viewingIdentity',viewingIdentity, searchIdentity);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'remote_run_action_sequence_authorized:Qm329f83289hsf',\n                            dataForAction: {\n                              type: 'remote_action_sequence_input:Qmf8329j29388923h8f22f',\n                              data: {\n                                // who to search (by identity, token) \n                                // action_sequence array \n                                \n                                identity: searchIdentity,\n                                // internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                \n                                actions: [\n                                  \n                                  // identify_via_token is added automatically to the beginning of the sequence\n                                  // {\n                                  //   matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                                  //   dataForAction: {\n                                  //     type: 'string:...',\n                                  //     data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                                  //   }\n                                  // },\n                              \n                                  // Part 1/3\n                                  // Fetch MY threads (where I am the author) \n                                  // - of a \"post:Qmfdlsj\" type \n                                  // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                                  {\n                                    matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'shared_data_request:Qmsdfljsdj',\n                                      data: {\n                                        // filter on the ENTIRE shared_node (NOT just on the shared_node data) \n                                        dataFilter: {\n                                          'data.signer': viewIdentity,\n                                          'data.data.author' : viewIdentity\n                                        },\n                                      }\n                                    }\n                                  },\n                                  \n                                  // Part 2/3 \n                                  // - reduce above (from requestCache) to thread_ref, and use in next step! \n                                  {\n                                    matchActionType: 'reduce_search:Qmlfjsdlsf',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'reduce_request:Qmsf89h923sf',\n                                      data: {\n                                      \n                                        type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                        data: {\n                                          code: `(()=>{\n                                            return new Promise(async (resolve,reject)=>{\n                                              // Part 2/3\n                                              // Reduce for next step \n                                              // - setting requestVariables too \n                                              \n                                              let requestCache = INPUT.data.requestCache; \n                                              // await universe.getRequestCache();\n                                              \n                                              let lastRequestResults;\n                                              try {\n                                                lastRequestResults = requestCache.keyvalue.request1; // 1st/2nd request (depending on authtoken)\n                                              }catch(err){\n                                                console.error(err);\n                                              }\n                                              \n                                              lastRequestResults = lastRequestResults || [];\n                                              \n                                              let threadRefs = lastRequestResults.map(req=>{\n                                                return req.data.data.thread_ref;\n                                              });\n                                              \n                                              \n                                              // return inputNode;\n                                              return resolve({\n                                                type: 'array_of_refs:Qmdslfjsdlf22',\n                                                data: {\n                                                  refs: threadRefs\n                                                }\n                                              });\n                                              \n                                            });\n                                          })()`\n                                        }\n                                      },\n                                      \n                                    }\n                                  },\n                                  \n                                  \n                                  // Part 3/3\n                                  // Fetch data for thread_refs (includes My results too) \n                                  // - of a \"post:Qmfdlsj\" type \n                                  // - use the returned thread_ref to find ALL the related (by me or not) Posts (and other data too, I suppose) \n                                  {\n                                    matchActionType: 'search_shared_data:Qmksdjhfwekjhdds24f',\n                                    dataForAction: {\n                                      // type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                                      type: 'shared_data_request:Qmsdfljsdj',\n                                      data: {\n                                        dataFilter: {\n                                          'data.data.thread_ref': {\n                                            // $in: \"[[$$test.test1$$]]\",\n                                            $in: \"[[$$(INPUT.data.requestCache.keyvalue.request2.data.refs)$$]]\"\n                                          }\n                                        },\n                                      }\n                                    }\n                                  },\n                                  \n                                  // TODO: clear results I dont care about (map->reduce...kill all the map results!) \n                                  \n                                ]\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[1].data.actionResponses[3].data;\n              \n              console.log('Posts:', nodes.length, nodes);\n              \n              // Create trees from nodes (in_reply_to) \n              // - get all of my unique Posts \n              let SharedDataNodes = universe.lodash.uniq(nodes.filter(node=>{\n                // filter \n                return node.data.data.author == viewIdentity;\n              }), node=>{\n                // uniq filter \n                return node.data._id; // unique id of source (identity:address) \n              }).sort((a,b)=>{\n                // newest at top \n                return a.data.data.createdAt < b.data.data.createdAt;\n              });\n              \n              \n              this.setState({\n                SharedDataNodes,\n                // fetchingMine: false\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes', err);\n            }\n            \n              \n            this.setState({\n              fetchingRemote: false\n            });\n            \n          \n          });\n          \n        }\n        \n        @autobind\n        handleViewMessage(messageNode){\n          // View a Code Package \n          console.log('messageNode', messageNode);\n          \n          this.setState({\n            tabsPackageMainSelected: 'details-222222',\n            selectedMessageNode: messageNode,\n            codePackageOutputNode: null // kill previous output result\n          });\n          \n        }\n        \n        @autobind\n        handleUpdateSyndicationSearchTarget(e){\n          // TODO: add multiple groups, identities, deny rules, etc. ! \n          this.setState({\n            searchIdentity: e.target.value\n          });\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: this.props.state.OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          {\n                            matchActionType: 'create_node:Qmf3892j39f8h9babb',\n                            dataForAction: {\n                              type: 'create_node_data:Qmdslkfj29f0j82',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[1];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        renderInboxList(){\n          \n          // rootMessageNode = {\n          //   _id: 'internal_id',\n          //   type: 'wrapped_message_node:...',\n          //   data: {\n          //     \"type\": \"message_node:Qmtesting\",\n          //     \"data\": {\n          //       \"type\": \"signed_message:Qmtesting\",\n          //       \"data\": {\n          //         \"msgId\": \"50c7f6ee-695f-4e29-a1db-c257d0ce6b0a\",\n          //         \"to\": \"\",\n          //         \"from\": \"testblah00000001\",\n          //         \"content\": {\n          //           \"type\": \"text:Qmtesting\",\n          //           \"data\": {\n          //             \"text\": \"text body of incoming message is this!!\"\n          //           }\n          //         },\n          //         \"sig\": \"1FIdVqx2+tGsPbUq8BxdRuIEIBpEgzpmtt9nYN7VUtxyaG8r7w45Hc3veB9Sxlm11wlD1xTOdeu+Gq+zBem0BQ==\"\n          //       }\n          //     }\n          //   }\n          // }\n\n          // console.log('Rendering MainHomeComponent.renderSnippets');\n          if(!this.state.inboxNodes.length && this.state.fetchingMine){\n            return (\n              <div>\n                <i>Finding inbox messages</i>\n              </div>\n            )  \n          }\n          \n          return (\n            <table className=\"table is-narrow\" style={{width: '100%'}}>\n              {/*<thead>\n                <th>From</th>\n                <th>Message</th>\n                <th>Note</th>\n                <th>Created</th>\n              </thead>\n              */}\n              <tbody>\n                {\n                  this.state.inboxNodes.filter(rootMessageNode=>{\n                    return (JSON.stringify(rootMessageNode.data)).toLowerCase().indexOf(this.state.filterText.toLowerCase()) > -1\n                  }).map((rootMessageNode,idx)=>{\n                    \n                    let author = 'unknown',\n                      createdAt = '',\n                      content = '',\n                      note = '';\n                    try {\n                      author = rootMessageNode.data.data.data.from;\n                      content = rootMessageNode.data.data.data.content.data.text;\n                      createdAt = universe.moment(rootMessageNode.createdAt, 'x').fromNow()\n                    }catch(err){\n                    }\n                    try {\n                      let noteNode = universe.lodash.query(rootMessageNode.nodes,{type:{$like: 'metadata_note_text:'}});\n                      note = noteNode.data.text;\n                    }catch(err){\n                    }\n                    return (\n                      <tr key={rootMessageNode._id}>\n                        <td onClick={()=>this.handleViewMessage(rootMessageNode)} style={{cursor:'pointer'}}>\n                          @{\n                            author\n                          }\n                        </td>\n                        <td onClick={()=>this.handleViewMessage(rootMessageNode)} style={{cursor:'pointer'}}>\n                          <span>\n                            {\n                              content.substring(0,200)\n                            }\n                          </span>\n                        </td>\n                        <td>\n                          <span>\n                            {\n                              note.substring(0,200)\n                            }\n                          </span>\n                        </td>\n                        <td>\n                          <small>{createdAt}</small>\n                        </td>\n                      </tr>\n                    )\n                  }) \n                }\n              </tbody>\n            </table>\n          )\n        }\n        \n        @autobind\n        renderPackage(){\n          let messageNode = this.state.selectedMessageNode;\n          if(!messageNode){\n            return (\n              <div>\n                <br /><br /><br /><br />\n                <i>none selected</i>\n              </div>\n            )\n          }\n          \n          let tabsPackageMain = [\n            ['details','Details'],\n            // ['metadata','Metadata',]\n          ];\n          \n          // console.log('OutputNode:', OutputNode);\n          \n          return (\n            <div>\n              <br /><br /><br /><br />\n              <br /><br /><br /><br />\n              <h2 className=\"title is-6\">\n                {\n                  messageNode.data.data.data.content.data.text\n                }\n              </h2>\n              \n              <div className=\"tabs\" style={{display:'none'}}>\n                <ul>\n                  {\n                    tabsPackageMain.map(tab=>(\n                      <li key={tab[0]}\n                        onClick={e=>this.setState({tabsPackageMainSelected:tab[0]})}\n                        className={(this.state.tabsPackageMainSelected == tab[0]) ? 'is-active':''}\n                        ><a>{tab[1]}</a></li>\n                    ))\n                  }\n                </ul>\n              </div>\n              \n              {\n                this.state.tabsPackageMainSelected != 'details' ? '':\n                <div>\n                  <div>\n                    <strong>About:</strong> \n                  </div>\n                </div>\n              }\n              \n              \n            </div>\n          )\n          \n        }\n        \n        render(){\n          // console.log('Rendering MainHomeComponent');\n          return (\n            <div className=\"container is-fluid\" style={{marginTop:'0.75em'}}>\n              <div className=\"columns\">\n                <div className=\"column is-8\">\n                \n                  <br />\n                  \n                  <div className=\"field has-addons\" style={{display:'none'}}>\n                    <div className=\"control\">\n                      <button className={\"button is-default\"} onClick={this.fetchMine}>\n                        Fetch Mine\n                      </button>\n                      <button className={\"button is-default\"} onClick={e=>this.fetchFromRemoteForIdentity(this.props)}>\n                        Fetch Remote/Syndicated\n                      </button>\n                    </div>\n                    {\n                      !this.state.fetchingRemote ? '':\n                      <div className=\"control\">\n                        <a className=\"button is-loading\">\n                          &nbsp;\n                        </a>\n                      </div>\n                    }\n                  </div>\n                  \n                  {/* Filter */}\n                  <div className=\"field is-grouped\">\n                    \n                    <div className=\"control is-expanded\">\n                      <input className=\"input\" value={this.state.filterText} onChange={e=>this.setState({filterText:e.target.value})} placeholder=\"Filter Inbox\" />\n                    </div>\n                    \n                    <div className=\"control\" style={{width:'20%'}}>\n                    \n                      <div className=\"select\">\n                        <select onChange={this.handleUpdateTypeFilter} value={this.state.typeFilter}>\n                          <option selected>All Types</option>\n                          <option>Messages Only</option>\n                          <option>Not Messages</option>\n                        </select>\n                      </div>\n                      \n                    </div>\n            \n                    <div className=\"control\" style={{width:'20%', display:'none'}}>\n                    \n                      <div className=\"select\">\n                        <select onChange={this.handleUpdateSyndicationSearchTarget} value={this.state.searchIdentity}>\n                          <option>Source:</option>\n                          <option>Everybody</option>\n                          {\n                            this.state.allExternalConnections.filter(e=>{return e.data.identity}).map(externalIdentity=>(\n                              <option key={externalIdentity._id} value={externalIdentity.data.identity}>{externalIdentity.data.identity}</option>\n                            ))\n                          }\n                          {\n                            (!this.state.allExternalConnections.length && this.state.fetchingConnections) ?\n                            <option>Loading sources</option>\n                            :''\n                          }\n                        </select>\n                      </div>\n                      \n                    </div>\n                    \n                    <div className=\"control\" style={{width:'20%'}}>\n                    \n                      <div className=\"select\">\n                        <select>\n                          <option>Algorithm:</option>\n                          <option selected>Most Recent (all)</option>\n                          <option>Recent (popular)</option>\n                        </select>\n                      </div>\n                      \n                    </div>\n                    \n                    <div className=\"control\">\n                      <button className={\"button is-info \" + (this.state.fetchingForSearch ? 'is-loading':'')} onClick={this.fetchSelected}>\n                        Refresh\n                      </button>\n                    </div>\n                    \n                    {/*\n                    <div className=\"control\" style={{lineHeight:'34px'}}>\n                      |\n                    </div>\n                    */}\n                    \n                    \n                    <div className=\"control\">\n                      \n                      {/*\n                      <button className=\"button is-info\">\n                        <span>Create</span>\n                      </button>\n                      */}\n                      \n                      {/*\n                      <div className=\"dropdown is-hoverable\">\n                        <div className=\"dropdown-trigger\">\n                          <button className=\"button is-info\" aria-haspopup=\"true\" aria-controls=\"dropdown-menu3\">\n                            <span>New Package</span>\n                            <span className=\"icon is-small\">\n                              <i className=\"fas fa-angle-down\" aria-hidden=\"true\"></i>\n                            </span>\n                          </button>\n                        </div>\n                        <div className=\"dropdown-menu\" id=\"dropdown-menu3\" role=\"menu\">\n                          <div className=\"dropdown-content\">\n                            <a href=\"#\" className=\"dropdown-item\" onClick={e=>this.setState({showNewCode: !this.state.showNewCode})}>\n                              Code\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              App\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              Route\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              Action\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              Capability\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              Something for Sale\n                            </a>\n                            <a href=\"#\" className=\"dropdown-item\">\n                              Request for Something\n                            </a>\n                          </div>\n                        </div>\n                      </div>\n                      */}\n                      \n                    </div>\n                    \n                  </div>\n                  \n                  \n                  <hr />\n                  \n                    \n                  \n                  <br />\n                  \n                  <div>\n                    {\n                      this.renderInboxList()\n                    }\n                  </div>\n                  \n                </div>\n                \n                <div className=\"column is-6\">\n                  {\n                    this.renderPackage()\n                  }\n                </div>\n                \n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n      const styles = {\n        deleteIcon: {\n          position: 'absolute',\n          top: '0px',\n          right: '-24px',\n          cursor: 'pointer'\n        }\n      }\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainInboxComponent"
  }
}